Content-Length: 1003

{"params":{"workspaceFolders":[{"uri":"file:///d%3A/Lean/Lean4_byJLJ","name":"Lean4_byJLJ"}],"trace":"off","rootUri":"file:///d%3A/Lean/Lean4_byJLJ","processId":1428,"initializationOptions":{"hasWidgets":true,"editDelay":200},"clientInfo":{"version":"1.95.2","name":"Visual Studio Code"},"capabilities":{"workspace":{"workspaceEdit":{"resourceOperations":["create","rename","delete"],"documentChanges":true,"changeAnnotationSupport":{"groupsOnLabel":true}},"applyEdit":true},"window":{"showDocument":{"support":true}},"textDocument":{"completion":{"completionItem":{"insertReplaceSupport":true}},"codeAction":{"resolveSupport":{"properties":["edit"]},"isPreferredSupport":true,"honorsChangeAnnotations":false,"dynamicRegistration":true,"disabledSupport":true,"dataSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}}}}},"method":"initialize","jsonrpc":"2.0","id":0}Content-Length: 6857

{"params":{"textDocument":{"version":1,"uri":"file:///d%3A/Lean/Lean4_byJLJ/.lake/packages/mathlib/Mathlib/Tactic/Cases.lean","text":"/-\nCopyright (c) 2022 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\nimport Lean.Elab.Tactic.Induction\nimport Batteries.Tactic.OpenPrivate\nimport Mathlib.Lean.Expr.Basic\nimport Batteries.Data.List.Basic\n\n/-!\n# Backward compatible implementation of lean 3 `cases` tactic\n\nThis tactic is similar to the `cases` tactic in Lean 4 core, but the syntax for giving\nnames is different:\n\n```\nexample (h : p ∨ q) : q ∨ p := by\n  cases h with\n  | inl hp => exact Or.inr hp\n  | inr hq => exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  cases' h with hp hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  rcases h with hp | hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n```\n\nPrefer `cases` or `rcases` when possible, because these tactics promote structured proofs.\n-/\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Elab.Tactic\n\nprivate def getAltNumFields (elimInfo : ElimInfo) (altName : Name) : TermElabM Nat := do\n  for altInfo in elimInfo.altsInfo do\n    if altInfo.name == altName then\n      return altInfo.numFields\n  throwError \"unknown alternative name '{altName}'\"\n\ndef ElimApp.evalNames (elimInfo : ElimInfo) (alts : Array ElimApp.Alt) (withArg : Syntax)\n    (numEqs := 0) (generalized : Array FVarId := #[]) (toClear : Array FVarId := #[])\n    (toTag : Array (Ident × FVarId) := #[]) :\n    TermElabM (Array MVarId) := do\n  let mut names : List Syntax := withArg[1].getArgs |>.toList\n  let mut subgoals := #[]\n  for { name := altName, mvarId := g, .. } in alts do\n    let numFields ← getAltNumFields elimInfo altName\n    let (altVarNames, names') := names.splitAtD numFields (Unhygienic.run `(_))\n    names := names'\n    let (fvars, g) ← g.introN numFields <| altVarNames.map (getNameOfIdent' ·[0])\n    let some (g, subst) ← Cases.unifyEqs? numEqs g {} | pure ()\n    let (introduced, g) ← g.introNP generalized.size\n    let subst := (generalized.zip introduced).foldl (init := subst) fun subst (a, b) =>\n      subst.insert a (.fvar b)\n    let g ← liftM <| toClear.foldlM (·.tryClear) g\n    g.withContext do\n      for (stx, fvar) in toTag do\n        Term.addLocalVarInfo stx (subst.get fvar)\n      for fvar in fvars, stx in altVarNames do\n        (subst.get fvar).addLocalVarInfoForBinderIdent ⟨stx⟩\n    subgoals := subgoals.push g\n  pure subgoals\n\nopen private getElimNameInfo generalizeTargets generalizeVars from Lean.Elab.Tactic.Induction\n/-- The `induction'` tactic is similar to the `induction` tactic in Lean 4 core,\nbut with slightly different syntax (such as, no requirement to name the constructors).\n\n```\nopen Nat\n\nexample (n : ℕ) : 0 < factorial n := by\n  induction' n with n ih\n  · rw [factorial_zero]\n    simp\n  · rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n\nexample (n : ℕ) : 0 < factorial n := by\n  induction n\n  case zero =>\n    rw [factorial_zero]\n    simp\n  case succ n ih =>\n    rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n```\n -/\nelab (name := induction') \"induction' \" tgts:(Parser.Tactic.casesTarget,+)\n    usingArg:((\" using \" ident)?)\n    withArg:((\" with\" (ppSpace colGt binderIdent)+)?)\n    genArg:((\" generalizing\" (ppSpace colGt ident)+)?) : tactic => do\n  let (targets, toTag) ← elabCasesTargets tgts.1.getSepArgs\n  let g :: gs ← getUnsolvedGoals | throwNoGoalsToBeSolved\n  g.withContext do\n    let elimInfo ← getElimNameInfo usingArg targets (induction := true)\n    let targets ← addImplicitTargets elimInfo targets\n    evalInduction.checkTargets targets\n    let targetFVarIds := targets.map (·.fvarId!)\n    g.withContext do\n      let genArgs ← if genArg.1.isNone then pure #[] else getFVarIds genArg.1[1].getArgs\n      let forbidden ← mkGeneralizationForbiddenSet targets\n      let mut s ← getFVarSetToGeneralize targets forbidden\n      for v in genArgs do\n        if forbidden.contains v then\n          throwError \"variable cannot be generalized \\\n            because target depends on it{indentExpr (mkFVar v)}\"\n        if s.contains v then\n          throwError \"unnecessary 'generalizing' argument, \\\n            variable '{mkFVar v}' is generalized automatically\"\n        s := s.insert v\n      let (fvarIds, g) ← g.revert (← sortFVarIds s.toArray)\n      g.withContext do\n        let result ← withRef tgts <| ElimApp.mkElimApp elimInfo targets (← g.getTag)\n        let elimArgs := result.elimApp.getAppArgs\n        ElimApp.setMotiveArg g elimArgs[elimInfo.motivePos]!.mvarId! targetFVarIds\n        g.assign result.elimApp\n        let subgoals ← ElimApp.evalNames elimInfo result.alts withArg\n          (generalized := fvarIds) (toClear := targetFVarIds) (toTag := toTag)\n        setGoals <| (subgoals ++ result.others).toList ++ gs\n\n/-- The `cases'` tactic is similar to the `cases` tactic in Lean 4 core, but the syntax for giving\nnames is different:\n\n```\nexample (h : p ∨ q) : q ∨ p := by\n  cases h with\n  | inl hp => exact Or.inr hp\n  | inr hq => exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  cases' h with hp hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  rcases h with hp | hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n```\n\nPrefer `cases` or `rcases` when possible, because these tactics promote structured proofs.\n-/\nelab (name := cases') \"cases' \" tgts:(Parser.Tactic.casesTarget,+) usingArg:((\" using \" ident)?)\n  withArg:((\" with\" (ppSpace colGt binderIdent)+)?) : tactic => do\n  let (targets, toTag) ← elabCasesTargets tgts.1.getSepArgs\n  let g :: gs ← getUnsolvedGoals | throwNoGoalsToBeSolved\n  g.withContext do\n    let elimInfo ← getElimNameInfo usingArg targets (induction := false)\n    let targets ← addImplicitTargets elimInfo targets\n    let result ← withRef tgts <| ElimApp.mkElimApp elimInfo targets (← g.getTag)\n    let elimArgs := result.elimApp.getAppArgs\n    let targets ← elimInfo.targetsPos.mapM (instantiateMVars elimArgs[·]!)\n    let motive := elimArgs[elimInfo.motivePos]!\n    let g ← generalizeTargetsEq g (← inferType motive) targets\n    let (targetsNew, g) ← g.introN targets.size\n    g.withContext do\n      ElimApp.setMotiveArg g motive.mvarId! targetsNew\n      g.assign result.elimApp\n      let subgoals ← ElimApp.evalNames elimInfo result.alts withArg\n         (numEqs := targets.size) (toClear := targetsNew) (toTag := toTag)\n      setGoals <| subgoals.toList ++ gs\n\nend Mathlib.Tactic\n","languageId":"lean"},"dependencyBuildMode":"always"},"method":"textDocument/didOpen","jsonrpc":"2.0"}Content-Length: 33

{"method":"exit","jsonrpc":"2.0"}